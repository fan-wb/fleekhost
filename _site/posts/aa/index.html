<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="en" >
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  ><!-- Setup Open Graph image -->

  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="账户抽象架构设计详解" />
<meta property="og:locale" content="en" />
<meta name="description" content="本文将从零开始，逐步构建起 ERC-4337 中账户抽象的架构。本文主要面向有智能合约基础知识，但对账户抽象不甚了解的读者。文中描述的 API 和行为可能与最终版的 ERC-4337 存在部分差异。" />
<meta property="og:description" content="本文将从零开始，逐步构建起 ERC-4337 中账户抽象的架构。本文主要面向有智能合约基础知识，但对账户抽象不甚了解的读者。文中描述的 API 和行为可能与最终版的 ERC-4337 存在部分差异。" />
<link rel="canonical" href="https://fan-wb.github.io/posts/aa/" />
<meta property="og:url" content="https://fan-wb.github.io/posts/aa/" />
<meta property="og:site_name" content="Fanwb’s Blog" />
<meta property="og:image" content="https://fanwb.oss-cn-beijing.aliyuncs.com/img/Picasso3.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-08T12:00:00+08:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://fanwb.oss-cn-beijing.aliyuncs.com/img/Picasso3.png" />
<meta property="twitter:title" content="账户抽象架构设计详解" />
<meta name="twitter:site" content="@twitter_username" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-16T11:54:20+08:00","datePublished":"2023-04-08T12:00:00+08:00","description":"本文将从零开始，逐步构建起 ERC-4337 中账户抽象的架构。本文主要面向有智能合约基础知识，但对账户抽象不甚了解的读者。文中描述的 API 和行为可能与最终版的 ERC-4337 存在部分差异。","headline":"账户抽象架构设计详解","image":"https://fanwb.oss-cn-beijing.aliyuncs.com/img/Picasso3.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://fan-wb.github.io/posts/aa/"},"url":"https://fan-wb.github.io/posts/aa/"}</script>
<!-- End Jekyll SEO tag -->


  <title>账户抽象架构设计详解 | Fanwb's Blog
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">

  <link rel="manifest" href="/assets/img/favicons/site.webmanifest">

<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Fanwb's Blog">
<meta name="application-name" content="Fanwb's Blog">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    
      <link rel="preconnect" href="https://cdnjs.cloudflare.com" >
      <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.25.0/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  
    <!-- Switch the mode between dark and light. -->

<script type="text/javascript">
  class ModeToggle {
    static get MODE_KEY() {
      return 'mode';
    }
    static get MODE_ATTR() {
      return 'data-mode';
    }
    static get DARK_MODE() {
      return 'dark';
    }
    static get LIGHT_MODE() {
      return 'light';
    }
    static get ID() {
      return 'mode-toggle';
    }

    constructor() {
      if (this.hasMode) {
        if (this.isDarkMode) {
          if (!this.isSysDarkPrefer) {
            this.setDark();
          }
        } else {
          if (this.isSysDarkPrefer) {
            this.setLight();
          }
        }
      }

      let self = this;

      /* always follow the system prefers */
      this.sysDarkPrefers.addEventListener('change', () => {
        if (self.hasMode) {
          if (self.isDarkMode) {
            if (!self.isSysDarkPrefer) {
              self.setDark();
            }
          } else {
            if (self.isSysDarkPrefer) {
              self.setLight();
            }
          }

          self.clearMode();
        }

        self.notify();
      });
    } /* constructor() */

    get sysDarkPrefers() {
      return window.matchMedia('(prefers-color-scheme: dark)');
    }

    get isSysDarkPrefer() {
      return this.sysDarkPrefers.matches;
    }

    get isDarkMode() {
      return this.mode === ModeToggle.DARK_MODE;
    }

    get isLightMode() {
      return this.mode === ModeToggle.LIGHT_MODE;
    }

    get hasMode() {
      return this.mode != null;
    }

    get mode() {
      return sessionStorage.getItem(ModeToggle.MODE_KEY);
    }

    /* get the current mode on screen */
    get modeStatus() {
      if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) {
        return ModeToggle.DARK_MODE;
      } else {
        return ModeToggle.LIGHT_MODE;
      }
    }

    setDark() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE);
    }

    setLight() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE);
    }

    clearMode() {
      document.documentElement.removeAttribute(ModeToggle.MODE_ATTR);
      sessionStorage.removeItem(ModeToggle.MODE_KEY);
    }

    /* Notify another plugins that the theme mode has changed */
    notify() {
      window.postMessage(
        {
          direction: ModeToggle.ID,
          message: this.modeStatus
        },
        '*'
      );
    }

    flipMode() {
      if (this.hasMode) {
        if (this.isSysDarkPrefer) {
          if (this.isLightMode) {
            this.clearMode();
          } else {
            this.setLight();
          }
        } else {
          if (this.isDarkMode) {
            this.clearMode();
          } else {
            this.setDark();
          }
        }
      } else {
        if (this.isSysDarkPrefer) {
          this.setLight();
        } else {
          this.setDark();
        }
      }

      this.notify();
    } /* flipMode() */
  } /* ModeToggle */

  const modeToggle = new ModeToggle();
</script>

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/微信图片_20240125105358.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a>

    <h1 class="site-title">
      <a href="/">Fanwb's Blog</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">The Revolution Will Be Decentralized.</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>HOME</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>CATEGORIES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tag"></i>
            

            <span>TAGS</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>ARCHIVES</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>ABOUT</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button type="button" class="mode-toggle btn" aria-label="Switch Mode">
        <i class="fas fa-adjust"></i>
      </button>

      
        <span class="icon-border"></span>
      
    

    
      

      
        <a
          href="https://github.com/fan-wb"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://twitter.com/twitter_username"
          aria-label="twitter"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fa-brands fa-square-x-twitter"></i>
        </a>
      
    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['fanwb.eth','outlook.com'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="/feed.xml"
          aria-label="rss"
          

          

          

          
        >
          <i class="fas fa-rss"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">Home</a>
            </span>

          
        
          
        
          
            
              <span>账户抽象架构设计详解</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      Post
    </div>

    <button type="button" id="search-trigger" class="btn btn-link">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="Search..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->




  
  

  
    
      
      
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    
      

      
      
      

      
    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  
    

    
    

    

    
    

    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    
    

    

    
      
    

    <!-- lazy-load images -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        

        
        
      
    

    <!-- combine -->
    
  

  


<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->




<article class="px-1">
  <header>
    <h1 data-toc-skip>账户抽象架构设计详解</h1>

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        Posted
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1680926400"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Apr  8, 2023
</time>

      </span>

      <!-- lastmod date -->
      
        <span>
          Updated
          <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1726458860"
  data-df="ll"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  Sep 16, 2024
</time>

        </span>
      

      
        
        
        

        

        <div class="mt-3 mb-3">
          <a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/Picasso3.png" class="popup img-link preview-img shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/Picasso3.png"  alt="Preview Image" width="1200" height="630"  loading="lazy"></a></div>
      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          By

          <em>
            
              <a href="https://github.com/fan-wb">Fan-WB</a>
            
          </em>
        </span>

        <!-- read time -->
        <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="11226 words"
>
  <em>62 min</em> read</span>

      </div>
      <!-- .d-flex -->
    </div>
    <!-- .post-meta -->
  </header>

  <div class="content">
    <p>本文将从零开始，逐步构建起 ERC-4337 中账户抽象的架构。本文主要面向有智能合约基础知识，但对账户抽象不甚了解的读者。文中描述的 API 和行为可能与最终版的 ERC-4337 存在部分差异。</p>

<h2 id="自定义钱包"><span class="me-2">自定义钱包</span><a href="#自定义钱包" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>我们首先从一个简单的资产管理的场景出发：用户希望使用单个私钥签署大多数普通交易，但价格昂贵的 NFT 资产则需要同时用存放在银行保险库内的另一个私钥签署才能转移。</p>

<p>我们知道以太坊中的账户分为合约账户 (CA) 和外部账户 (EOA) 两类。EOA 由一个公私钥对控制，是“主动”的，可以发起交易并支付 EVM 执行的 gas 费，但只能执行基本操作（例如转账或与合约交互）。而 CA 则由智能合约的代码逻辑而非私钥控制，是“被动”的，只能响应来自 EOA 的交易，且不能支付 gas 费，但 CA 是可编程的，可以根据存储在该地址的代码执行任意逻辑。</p>

<p>那么问题来了：在我们的场景中，持有资产的账户应该是合约账户还是外部账户呢？</p>

<p>答案是：该账户必须是合约账户。因为如果是 EOA 的话，那么所有资产都可以被其私钥签署的交易随意转移，无法满足我们设定的安全需求。</p>

<p>因此，我们的链上身份将由一个智能合约代表，该合约被称为“智能合约钱包”。我们需要一种方式向这个钱包发出指令，使其能像 EOA 一样执行我们期望的转账或合约调用操作。</p>

<blockquote class="prompt-tip">
  <p>使用这种方式管理资产的用户必须有自己的智能合约。不能用一个大型合约来持有多人的资产，因为整个以太坊生态都预设了一个地址代表一个实体，共用合约钱包的用户是无法被区分的。</p>
</blockquote>

<h3 id="用户操作"><span class="me-2">用户操作</span><a href="#用户操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>我们部署一个用来持有资产的智能合约，并提供一个方法，通过这个方法可以向合约传递用户希望执行的操作的信息，我们称其为用户操作 (User Operation)。</p>

<p>钱包合约如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>contract Wallet {
  function executeOp(UserOperation op);
}
</pre></td></tr></tbody></table></code></div></div>

<p>用户操作中具体包含哪些信息呢？</p>

<p>首先是传给 <code class="language-plaintext highlighter-rouge">eth_sendTransaction</code> 的参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>struct UserOperation {
  address to;
  bytes data;
  uint256 value;
  uint256 gas;
  // ...
}
</pre></td></tr></tbody></table></code></div></div>

<p>此外，还需要提供用来授权请求的数据，钱包会根据这段数据来决定是否执行操作。</p>

<p>在我们的场景中，对于大部分用户操作，只需要传递主密钥对其余操作数据的签名即可。但如果用户操作是转移 NFT，那么钱包将要求用户提供两个私钥分别对操作数据的签名。</p>

<p>最后，还要加入一个随机数 (nonce)以防止重放攻击：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>struct UserOperation {
  // ...
  bytes signature;
  uint256 nonce;
}
</pre></td></tr></tbody></table></code></div></div>

<p>至此，钱包合约达成了我们的目标：用户的 NFT 由该合约持有时，没有两个私钥签名就无法被转移。</p>

<h3 id="合约钱包调用"><span class="me-2">合约钱包调用</span><a href="#合约钱包调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>还有一个问题是如何调用 <code class="language-plaintext highlighter-rouge">executeOp(op)</code>。由于没有用户的私钥签名合约不会执行任何操作，因此所有人都可以尝试进行调用，不会有安全风险。但要想执行操作，就一定得有人实际调用该方法。</p>

<p>在以太坊上，只有 EOA 能发起交易，进行调用的 EOA 必须使用自己的 ETH 支付 gas 费。</p>

<p>我们可以单独设置一个 EOA，仅用于调用钱包合约。虽然这个 EOA 没有钱包合约那样的双重签名保护，但它只需要持有足够支付调用 gas 费的 ETH 即可，大部分资产仍由更安全的钱包合约持有。</p>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w01.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w01.svg" alt="" loading="lazy"></a>
<em>用户使用单独的 EOA 调用智能合约钱包</em></p>

<p>由此，我们只用一个相当简单的合约就实现了大部分账户抽象的功能。</p>

<h2 id="无需-eoa"><span class="me-2">无需 EOA</span><a href="#无需-eoa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>上述方案的缺点是用户需要运行一个单独的 EOA 来调用钱包合约，增加了流程的复杂性。那么假如用户愿意自己支付 gas 费，但不想维护两个账户怎么办？</p>

<p>前面提到钱包合约的 <code class="language-plaintext highlighter-rouge">executeOp</code> 方法可以被任何人调用，因此用户可以请求其他拥有 EOA 的人代为调用。我们暂时称这个 EOA 及其所有者为“执行器” (executor)。</p>

<p>由于执行器需要支付调用产生的 gas 费，我们可以让钱包合约持有一些 ETH，并在调用中令其向执行器转账作为 gas 费补偿。</p>

<blockquote class="prompt-tip">
  <p>“执行器”并不是 ERC-4337 中的术语，但很好地描述了这个参与者的作用。后文会将其替换为 ERC-4337 中实际使用的术语 “bundler”（打包器），但由于目前我们还没有涉及到打包操作，因此用“执行器”更合理。其他协议中也称此类参与者为 “relayer”（中继器）。</p>
</blockquote>

<p>当前钱包的接口是：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>contract Wallet {
  function executeOp(UserOperation op);
}
</pre></td></tr></tbody></table></code></div></div>

<p>我们将尝试修改 <code class="language-plaintext highlighter-rouge">executeOp</code> 的行为，使其在执行完操作后，根据所使用的 gas 量向执行器支付适当数额的 ETH 作为 gas 费补偿。</p>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w02.drawio.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w02.drawio.svg" alt="" loading="lazy"></a>
<em>由执行器而非用户的 EOA 调用智能合约钱包</em></p>

<p>这一方案的问题在于执行器需要确保钱包真的会支付 gas 费补偿。如果执行器调用 <code class="language-plaintext highlighter-rouge">executeOp</code> 但钱包并未退还 gas 费，执行器将不得不自己承担费用。</p>

<p>为了避免这种情况，执行器可以尝试在本地模拟 <code class="language-plaintext highlighter-rouge">executeOp</code> 操作，如使用 <code class="language-plaintext highlighter-rouge">debug_traceCall</code>，并检查是否会得到 gas 费补偿。在确认可以获得补偿后，执行器才会发送实际的交易。</p>

<p>但模拟并不总能完美预测真实的执行情况。完全有可能在模拟时钱包支付了 gas 费，但在实际将交易添加到区块时却支付失败。作恶钱包甚至会故意这样做，免费执行自己的操作并给执行器留下巨额的 gas 账单。</p>

<p><strong>模拟与真实执行可能不一致的原因包括:</strong></p>

<ul>
  <li>操作可能会读取存储，而存储可能在模拟和真实执行之间发生变化。</li>
  <li>操作可能会使用像 <code class="language-plaintext highlighter-rouge">TIMESTAMP</code>、<code class="language-plaintext highlighter-rouge">BLOCKHASH</code>、<code class="language-plaintext highlighter-rouge">BASEFEE</code> 等操作码。这些操作码会从环境中读取信息，且这些信息在不同区块中是不可预测的。</li>
</ul>

<p>执行器可以尝试限制操作的允许范围，例如拒绝所有使用“环境”操作码的操作，但这种限制过于严格。要注意，我们希望钱包能执行 EOA 能力范围内的所有操作，而禁用这些操作码会妨碍许多合理的使用场景。例如，钱包将无法与大量使用 <code class="language-plaintext highlighter-rouge">TIMESTAMP</code> 的 Uniswap 等 DApp 交互，这无疑与我们的初衷相悖。</p>

<p>由于钱包的 <code class="language-plaintext highlighter-rouge">executeOp</code> 可以包含任意代码，我们无法合理地对其进行限制来防止对模拟的欺骗，因此在当前接口下这个问题是无解的。<code class="language-plaintext highlighter-rouge">executeOp</code> 是一个黑箱，难以预测。</p>

<h3 id="入口点合约"><span class="me-2">入口点合约</span><a href="#入口点合约" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>前述问题的核心在于我们要求执行器运行来自不可信合约的代码，而执行器希望在具有一定保障的环境中执行这些不可信操作——这不正是智能合约的目的吗？</p>

<p>因此我们将引入一个新的可信（经过审计和源代码验证）合约，称为<strong>入口点</strong> (EntryPoint)，并为其提供一个由执行器调用的方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
    function handleOp(UserOperation op); // ...
}
</pre></td></tr></tbody></table></code></div></div>

<p><code class="language-plaintext highlighter-rouge">handleOp</code> 将执行以下操作：</p>

<ul>
  <li>检查钱包是否有足够的资金支付可能使用的最大 gas 费（基于用户操作中的 gas 字段）。如果没有，拒绝执行。</li>
  <li>调用钱包的 <code class="language-plaintext highlighter-rouge">executeOp</code> 方法（使用适当的 gas 限额），并记录实际使用的 gas 量。</li>
  <li>从钱包中取出一些 ETH 支付给执行器，作为 gas 费补偿。</li>
</ul>

<p>要实现第三点，我们需要让入口点来持有用于支付 gas 费的 ETH。因为正如前文所述，我们无法确保能从钱包中取出 ETH。因此，还需要一个方法，让钱包向入口点存入支付 gas 费的 ETH，并提供另一个方法让钱包在需要时能将 ETH 取出：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
    // ...
    function deposit(address wallet) payable;
    function withdrawTo(address payable destination); 
}
</pre></td></tr></tbody></table></code></div></div>

<p>用这种实现，我们可以确保执行器获得 gas 费补偿。</p>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w03-1.drawio.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w03-1.drawio.svg" alt="" loading="lazy"></a>
<em>引入经审计和源代码验证的入口点合约，可确保执行器获得补偿</em></p>

<p>执行器的问题迎刃而解，但对于钱包来说，新问题又出现了。</p>

<h3 id="拆分验证与执行"><span class="me-2">拆分验证与执行</span><a href="#拆分验证与执行" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>我们之前将钱包的接口定义为：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>contract Wallet { 
    function executeOp(UserOperation op); 
}
</pre></td></tr></tbody></table></code></div></div>

<p>这个方法实际上做了两件事：验证用户操作是否被授权，以及执行操作中指定的调用。当钱包的所有者使用自己的账户支付 gas 费时，这种区分并不重要，但现在我们要求执行器支付 gas 费，区分验证和执行就很关键了。</p>

<p>当前的实现是，无论如何钱包都会向执行器退还 gas 费。但其实如果验证失败，钱包就不应支付费用。</p>

<p>因为<strong>验证失败</strong>，意味着某个没有权限的人要求钱包执行某个操作。在这种情况下，钱包的 <code class="language-plaintext highlighter-rouge">executeOp</code> 会正确地阻止该操作执行，但根据当前实现，钱包仍要支付 gas 费。利用这点，与钱包没有任何关系的人也可以请求大量操作，耗尽钱包的 gas 资金。与之相对，如果验证成功但操作<strong>执行失败</strong>，则钱包应该支付 gas 费。这表示钱包所有者授权执行的操作最终没有成功，就像从 EOA 发送一个回滚的交易一样，由于用户进行了授权，因此应该为 gas 付费。</p>

<p>当前的 <code class="language-plaintext highlighter-rouge">executeOp</code> 接口无法区分验证失败和执行失败，因此我们需要将其拆分为两部分。</p>

<p><strong>新钱包接口</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Wallet {
    function validateOp(UserOperation op);
    function executeOp(UserOperation op);
}
</pre></td></tr></tbody></table></code></div></div>

<p><strong>入口点的 <code class="language-plaintext highlighter-rouge">handleOp</code> 新实现</strong>：</p>

<ul>
  <li>调用 <code class="language-plaintext highlighter-rouge">validateOp</code>。如果失败，停止执行。</li>
  <li>从钱包的存款中预留 ETH，用于支付可能使用的最大 gas 费（基于操作的 gas 字段）。如果钱包存款不足，拒绝执行。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">executeOp</code> 并跟踪实际使用的 gas 量。无论此调用成功或失败，都从预留的资金中向执行器退还 gas 费，剩余资金返还给钱包存款。</li>
</ul>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w04.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w04.svg" alt="" loading="lazy"></a>
<em>拆分验证与执行以区别验证失败和执行失败</em></p>

<p>这一实现对钱包来说很合理，只有其授权的操作才会被收取 gas 费。但对执行器而言，风险又增加了。</p>

<blockquote class="prompt-tip">
  <p>应该确保未经授权的用户不能直接调用钱包的 <code class="language-plaintext highlighter-rouge">executeOp</code>，防止钱包在未经验证的情况下执行操作。钱包可以通过强制 <code class="language-plaintext highlighter-rouge">executeOp</code> 只能由入口点合约调用来防止这种情况。</p>
</blockquote>

<blockquote class="prompt-tip">
  <p>为什么作恶钱包不能在 <code class="language-plaintext highlighter-rouge">validateOp</code> 中执行所有操作？这样如果执行失败就不会被收取 gas 费。后文将说明 <code class="language-plaintext highlighter-rouge">validateOp</code> 会受到严格的限制，使其不适合执行真正的操作。</p>
</blockquote>

<h3 id="模拟机制"><span class="me-2">模拟机制</span><a href="#模拟机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>当前实现下，当未经授权的用户为钱包提交操作时，<code class="language-plaintext highlighter-rouge">validateOp</code> 会失败，钱包不必支付任何费用。但执行器仍需为 <code class="language-plaintext highlighter-rouge">validateOp</code> 的链上执行支付 gas 费，且不会获得补偿。</p>

<p>作恶钱包无法再免费执行操作，但仍能令执行器为失败的操作支付 gas 费并损失资金。</p>

<p>在之前的模拟中，执行器会先在本地模拟操作，只有在模拟成功时才会提交链上交易调用 <code class="language-plaintext highlighter-rouge">handleOp</code>。但执行器无法合理地限制执行来防止模拟成功但真实交易失败的情况发生。</p>

<p>但在我们拆分了操作的验证和执行后，执行器只需要模拟 <code class="language-plaintext highlighter-rouge">validateOp</code>，就能知道是否会获得补偿。与 <code class="language-plaintext highlighter-rouge">executeOp</code> 不同，对 <code class="language-plaintext highlighter-rouge">validateOp</code> 施加更严格的限制不会影响钱包与区块链的自由交互。</p>

<p>具体而言，只有当 <code class="language-plaintext highlighter-rouge">validateOp</code> 满足以下限制时，执行器才会向链上提交用户操作：</p>

<ol>
  <li>不使用禁用列表中的操作码，包括 <code class="language-plaintext highlighter-rouge">TIMESTAMP</code>、<code class="language-plaintext highlighter-rouge">BLOCKHASH</code> 等。</li>
  <li>只访问钱包的<strong>关联存储</strong>，定义为以下任一情况：
    <ul>
      <li>钱包自身的存储</li>
      <li>另一个合约在 <code class="language-plaintext highlighter-rouge">mapping(address =&gt; value)</code> 中与钱包地址对应的存储位置</li>
      <li>另一个合约中与钱包地址相同的存储位置（非常规做法）</li>
    </ul>
  </li>
</ol>

<p>这些规则旨在最小化模拟与实际执行不一致的风险。禁用操作码很好理解，存储限制的思路是：任何存储访问都会增加模拟失真的风险，因为该存储位置可能在模拟和执行期间发生变化。但如果将存储限制为与此钱包相关的位置，那么恶意者就需要更新与钱包相关的特定存储才能使模拟失真，其成本足以阻止恶意者。</p>

<p>在这种模拟机制下，钱包和执行器都是安全的。</p>

<blockquote class="prompt-tip">
  <p>对 <code class="language-plaintext highlighter-rouge">validateOp</code> 存储访问的限制还有另一个好处：由于 <code class="language-plaintext highlighter-rouge">validateOp</code> 只能访问与该钱包关联的特定存储位置，而不同钱包的关联存储位置是相互独立的，因此针对不同钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 调用不会相互影响。这种互不干扰的特性对于并行处理多个钱包的操作是非常有利的，这一点对后文将讨论的“打包”操作非常重要。</p>
</blockquote>

<h3 id="钱包直接支付"><span class="me-2">钱包直接支付</span><a href="#钱包直接支付" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>目前，钱包支付 gas 费的方式是先将 ETH 存入入口点合约，然后再发送用户操作。但普通的 EOA 是直接用其 ETH 余额支付 gas 费的，我们的合约钱包也应该支持这点。</p>

<p>在拆分验证和执行后，入口点可以在验证步骤中<strong>要求</strong>钱包向其发送 ETH，否则拒绝执行操作，由此钱包就能直接支付 gas 费了。</p>

<p>我们需要更新钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 方法，使入口点能够向其索要资金，如果 <code class="language-plaintext highlighter-rouge">validateOp</code> 不向入口点支付所需金额，入口点就拒绝执行操作：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Wallet {
    function validateOp(UserOperation op, uint256 requiredPayment); 
    function executeOp(UserOperation op);
}
</pre></td></tr></tbody></table></code></div></div>

<p>由于在验证时我们无法确切知道执行期间将使用多少 gas，因此入口点会根据用户操作的 gas 字段，要求钱包支付可能使用的最大 gas 费。然后在执行结束时将未使用的 gas 费退还给钱包。</p>

<p>要注意，在编写智能合约时，直接向任意合约发送 ETH 是有风险的，因为这会调用该合约的代码，可能导致失败或消耗不可预测的 gas 量，甚至受到重入攻击。因此我们不能直接将多余的 gas 费退还给钱包，而是应保留这部分 ETH，并允许钱包调用提款方法将其取出，也就是所谓的“拉取支付”模式。</p>

<p>多余的 gas 费会被发送到 <code class="language-plaintext highlighter-rouge">deposit</code> 方法接收 ETH 的位置，钱包可以使用 <code class="language-plaintext highlighter-rouge">withdrawTo</code> 方法将其取出。这也就意味着钱包可以从两个位置支付 gas 费：入口点合约中为其所持有的 ETH，以及钱包自身持有的 ETH。这其实类似于支付宝余额和所绑定银行账户余额间的关系。</p>

<p>入口点会先尝试使用存入的 ETH 支付 gas 费，如果存款不足，则在调用钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 时要求支付剩余部分。</p>

<h3 id="执行器激励"><span class="me-2">执行器激励</span><a href="#执行器激励" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>到目前为止，执行器需要运行大量模拟，却没有任何利润，模拟失真时还要自费支付 gas 费。因此作为补偿，我们允许钱包所有者在用户操作中附加小费，这部分费用将归执行器所有。</p>

<p>在用户操作结构中添加一个字段来表示这一点：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>struct UserOperation {
    // ...
    uint256 maxPriorityFeePerGas; 
}
</pre></td></tr></tbody></table></code></div></div>

<p><code class="language-plaintext highlighter-rouge">maxPriorityFeePerGas</code> 表示发送方为获得操作处理优先权愿意支付的最高 gas 价格。</p>

<p>执行器在发送调用入口点 <code class="language-plaintext highlighter-rouge">handleOp</code> 方法的交易时，可以使用较低的 <code class="language-plaintext highlighter-rouge">maxPriorityFeePerGas</code>，并将差价作为自己的收益。</p>

<h3 id="单例入口点"><span class="me-2">单例入口点</span><a href="#单例入口点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>入口点的功能与特定的钱包或执行器无关。因此，入口点可以作为整个生态系统中的单例存在。所有钱包和执行器都与同一个入口点合进行约交互。</p>

<p>为此，我们需要调整用户操作的结构，使其能够指定该操作所针对的钱包地址，以便入口点的 <code class="language-plaintext highlighter-rouge">handleOp</code> 接收到操作时，知道要向哪个钱包请求验证和执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>struct UserOperation {
  // ...
  address sender;
}
</pre></td></tr></tbody></table></code></div></div>

<h3 id="小结"><span class="me-2">小结</span><a href="#小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>我们的目标是创建一个能自己支付 gas 费的链上钱包，且无需钱包所有者管理单独的外部账户。这一目标已经达成：</p>

<p>钱包接口如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Wallet {
  function validateOp(UserOperation op, uint256 requiredPayment);
  function executeOp(UserOperation op);
}
</pre></td></tr></tbody></table></code></div></div>

<p>整个区块链上通用的单例入口点接口如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
  function handleOp(UserOperation op);
  function deposit(address wallet) payable;
  function withdrawTo(address destination);
}
</pre></td></tr></tbody></table></code></div></div>

<p>当前用户的使用流程如下：</p>

<ol>
  <li>当钱包所有者想要执行某个操作时，会生成一个用户操作，并在链下请求一个执行器来处理。</li>
  <li>执行器模拟钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 方法，以决定是否接受该用户操作。</li>
  <li>如果接受，执行器会发送一笔交易给入口点合约，调用 <code class="language-plaintext highlighter-rouge">handleOp</code>。</li>
  <li>入口点会在链上处理验证和执行操作，并从钱包的存款中退款给执行器。</li>
</ol>

<h2 id="打包操作"><span class="me-2">打包操作</span><a href="#打包操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>目前，执行器发送一笔交易只能执行一个用户操作，效率较低。由于入口点不与特定钱包绑定，我们完全可以收集来自不同用户的一批操作，然后在单个交易中一次性执行以节省 gas 费，即<strong>打包操作</strong> (bundling)。</p>

<p>通过打包用户操作，用户无需重复支付固定的 21000 gas 交易发送费用，同时也能降低冷存储访问费用（在同一笔交易中多次访问相同的存储空间比第一次访问便宜）。</p>

<p>所需的改动很少，只需将：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
  function handleOp(UserOperation op);
  
  // ...
}
</pre></td></tr></tbody></table></code></div></div>

<p>替换为：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
  function handleOps(UserOperation[] ops);

  // ...
}
</pre></td></tr></tbody></table></code></div></div>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w05.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w05.svg" alt="" loading="lazy"></a>
<em>用户操作的打包、验证和执行</em></p>

<p><code class="language-plaintext highlighter-rouge">handleOps</code> 方法执行以下操作：</p>

<ul>
  <li>对于每个操作，在操作发送者钱包上调用 <code class="language-plaintext highlighter-rouge">validateOp</code>。任何未通过验证的操作都将被丢弃。</li>
  <li>对于每个操作，在操作发送者钱包上调用 <code class="language-plaintext highlighter-rouge">executeOp</code>，跟踪使用了多少 gas，然后将 ETH 转账执行器，用于支付 gas 费。</li>
</ul>

<p>这里需要注意的一点是，在处理操作时，入口点会先验证全部操作，然后再执行全部操作，而不是对每个操作分别进行验证和执行。这点对于模拟非常重要，如果 <code class="language-plaintext highlighter-rouge">handleOps</code> 时在验证下一个操作之前就执行了前一个操作，那么前一个操作的执行就有可能干扰第二个操作的验证所依赖的存储。</p>

<p>同样，也应当避免一个操作的验证干扰包中后续操作的验证。不过，只要包中不包含同一个钱包的多个操作，那么由于前述的存储限制，这点是很容易做到的：两个操作的验证不涉及相同的存储，就不会相互干扰。因此，执行器会确保包中每个钱包最多只包含一个操作。</p>

<p>在此机制下，执行器可以通过安排包中的用户操作顺序（可能插入自己的操作）来获得最大可提取价值 (MEV)。</p>

<p>引入打包操作后，我们将以 ERC-4337 中的术语“<strong>打包器</strong>” (bundler) 来称呼控制 EOA 的参与者，不再称其为“执行器”。</p>

<h3 id="网络参与"><span class="me-2">网络参与</span><a href="#网络参与" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>在当前机制下，钱包所有者向打包器提交用户操作，并希望操作能被包含在一个包中。这与区块链上普通交易的机制非常相似，即账户所有者向区块构建者提交交易，希望交易能被包含在一个区块中。我们可以从两者相似的网络结构中受益。</p>

<p>就像节点将普通交易存储在内存池中并广播给其他节点一样，打包器可以将验证后的用户操作存储在内存池中并广播给其他打包器。打包器可以在分享用户操作之前先对其进行验证，从而节省彼此验证操作的工作量。</p>

<p>打包器如果同时也是区块构建者，就可以选择包会被包含在哪个区块中，从而减少甚至消除在模拟成功后执行失败的可能性。此外，区块构建者和打包器能以类似的方式通过 MEV 获利。随着时间的推移，打包器和区块构建者的角色可能会逐渐融合。</p>

<h2 id="代付合约"><span class="me-2">代付合约</span><a href="#代付合约" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>目前，我们的钱包已经完全实现了 EOA 的功能，且允许用户自定义验证逻辑。但钱包仍然需要支付 gas 费，因此用户在进行链上操作之前需要先获取一些 ETH。</p>

<p>如果我们希望由其他人而非钱包所有者来支付 gas 费呢？例如下列情况：</p>

<ul>
  <li>钱包所有者可能是区块链新手，在进行链上操作之前获取 ETH 有一定门槛。</li>
  <li>Dapp 可能愿意为其方法支付 gas 费，以免 gas 费用吓退潜在用户。</li>
  <li>赞助商可能允许钱包使用其他代币支付 gas 费，例如USDC。</li>
  <li>出于隐私原因，用户可能希望从混币器中提取资产到一个新地址，由与其无关的账户支付 gas 费。</li>
</ul>

<p>当谈，几遍 Dapp 愿意为其用户支付 gas 费，也不可能替所有人的所有操作付费，因而需要在链上部署自定义逻辑的合约，来查看用户操作并决定是否为该操作支付 gas 费。我们将这样的合约称为<strong>代付者</strong> (Paymaster)。</p>

<p>该合约提供一个方法来查看用户操作并决定是否为其支付费用：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>contract Paymaster {
  function validatePaymasterOp(UserOperation op);
}
</pre></td></tr></tbody></table></code></div></div>

<p>然后，当钱包提交一个操作时，需要指明期望由哪个代付者（如有）来支付 gas 费。我们要在 <code class="language-plaintext highlighter-rouge">UserOperation</code> 中添加一个新字段来指定这点。此外，还需要在用户操作中添加一个字段，使钱包可以由此向代付合约传递数据，以说服其替自己买单。</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>struct UserOperation {
  // ...
  address paymaster;
  bytes paymasterData;
}
</pre></td></tr></tbody></table></code></div></div>

<p>接下来我们将修改入口点的 <code class="language-plaintext highlighter-rouge">handleOps</code> 方法，以使用新的代付合约。其行为如下：</p>

<ul>
  <li>对于每个操作：
    <ul>
      <li>在操作发送者的钱包上调用 <code class="language-plaintext highlighter-rouge">validateOp</code>。</li>
      <li>如果操作有代付合约地址，则调用该合约的 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code>。</li>
      <li>以上两种验证有一项以上未通过，则丢弃该操作。</li>
      <li>对每个操作，在操作发送者的钱包上调用 <code class="language-plaintext highlighter-rouge">executeOp</code>，跟踪使用了多少 gas，然后向执行器转账 ETH 来支付 gas 费。如果操作有代付者字段，则使用代付者的 ETH，否则仍使用钱包持有的 ETH。</li>
    </ul>
  </li>
</ul>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w06.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w06.svg" alt="" loading="lazy"></a>
<em>执行器同时调用代付合约和用户的合约钱包来确定交易是否被赞助</em></p>

<p>与钱包一样，代付合约也需要先通过入口点的 <code class="language-plaintext highlighter-rouge">deposit</code> 方法存入 ETH，然后才能支付操作费用。</p>

<h3 id="代付者质押"><span class="me-2">代付者质押</span><a href="#代付者质押" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>前文提到，打包器需要用模拟来避免执行未通过验证的操作，因为这种情况下打包器要为 gas 费买单，且不会得到钱包的补偿。</p>

<p>而引入代付者后，情况类似：打包器同样需要避免提交未通过代付者验证的操作。</p>

<p>初看之下，我们似乎可以对 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code> 使用与 <code class="language-plaintext highlighter-rouge">validateOp</code> 相同的限制（即只能访问钱包及其关联存储，且不能使用被禁止的操作码），打包器可以在模拟钱包 <code class="language-plaintext highlighter-rouge">validateOp</code> 的同时模拟用户操作的 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code>。</p>

<p>但这里有一个问题：</p>

<p>由于存储限制规定钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 只能访问该钱包相关的存储，因此只要操作来自不同的钱包，那么包中多个操作的验证就不会相互干扰，因为其共享的存储很少。但是代付合约的存储是被整个包中所有使用该代付者的操作共享的，这就意味着一个 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code> 的行为可能会导致包中许多使用该代付合约的其他操作验证失败。恶意代付者甚至可以利用这一点进行 DoS 攻击。</p>

<p>为了防止这种情况，我们需要引入一个信誉系统：让打包器跟踪每个代付者最近验证失败的频率，并通过限制或禁止使用该代付者的操作来惩罚经常失败的代付者。但如果恶意代付者可以轻松创建多个实例（女巫攻击），信誉系统就会失效。因此需要让代付者质押 ETH。</p>

<p>在入口点添加新方法来处理质押：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
    // ...
    function addStake() payable;
    function unlockStake(); 
    function withdrawStake(address payable destination);
}
</pre></td></tr></tbody></table></code></div></div>

<p>一旦质押被存入，只有调用 <code class="language-plaintext highlighter-rouge">unlockStake</code> 并经过一段延迟后才能取出。这些方法与之前讨论过的 <code class="language-plaintext highlighter-rouge">deposit</code> 和 <code class="language-plaintext highlighter-rouge">withdrawTo</code> 是不同的，后者可随时取出。</p>

<blockquote class="prompt-tip">
  <p>此处的质押不会被罚没。其存在的目的是令潜在攻击者必须锁定大量资金才能实施大规模攻击。</p>
</blockquote>

<h3 id="postop-方法"><span class="me-2"><code class="language-plaintext highlighter-rouge">postOp</code> 方法</span><a href="#postop-方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>目前，代付合约只在操作实际运行之前的验证步骤中被调用。</p>

<p>但代付者可能还需要根据操作的结果做出不同的处理。例如，一个支持使用 USDC 支付 gas 费的代付者需要知道操作实际使用了多少 gas，以确定应该收取多少 USDC。</p>

<p>因此，为代付合约添加一个新方法 <code class="language-plaintext highlighter-rouge">postOp</code>，入口点将在操作完成后调用该方法，传递实际使用的 gas 量。我们还希望代付者能将验证过程中的结果数据放到 <code class="language-plaintext highlighter-rouge">postOp</code> 中计算，因此允许验证返回任意的 context 数据，这些数据会被传递给 <code class="language-plaintext highlighter-rouge">postOp</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Paymaster {
    function validatePaymasterOp(UserOperation op) returns (bytes context); 
    function postOp(bytes context, uint256 actualGasCost);
}
</pre></td></tr></tbody></table></code></div></div>

<p>就上述例子而言，代付合约批准执行之前会检查用户有足够的 USDC 来支付操作费用。但完全有可能在执行过程中，操作将钱包的所有 USDC 都转走了，导致代付者最后无法获得付款。</p>

<blockquote class="prompt-tip">
  <p>代付者是否可以通过在开始时收取最大 USDC 金额，然后在结束时退还未使用的部分来避免这种情况？可以，但很麻烦。因为需要两次 <code class="language-plaintext highlighter-rouge">transfer</code> 调用，会增加 gas 成本并产生了两个不同的 <code class="language-plaintext highlighter-rouge">transfer</code> 事件。</p>
</blockquote>

<p>代付合约需要一种能令执行完成的操作失效的方法，同时还要确保即便如此，代付者应该仍能获得付款。实现的方法是令入口点能调用两次 <code class="language-plaintext highlighter-rouge">postOp</code>。</p>

<p>入口点会将调用 <code class="language-plaintext highlighter-rouge">postOp</code> 作为执行钱包 <code class="language-plaintext highlighter-rouge">executeOp</code> 的一部分，因此 <code class="language-plaintext highlighter-rouge">postOp</code> 回滚将导致 <code class="language-plaintext highlighter-rouge">executeOp</code> 的结果也回滚。这种情况下，入口点将再次调用 <code class="language-plaintext highlighter-rouge">postOp</code>，但此时 <code class="language-plaintext highlighter-rouge">executeOp</code> 尚未被执行，由于刚检查过 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code>，因此代付者能获取应得的费用。</p>

<p>为 <code class="language-plaintext highlighter-rouge">postOp</code> 添加旗标参数 <code class="language-plaintext highlighter-rouge">hasAlreadyReverted</code> 以提供更多上下文，该参数指示当前是否处于回滚过后的第二次运行中：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Paymaster {
    function validatePaymasterOp(UserOperation op) returns (bytes context);
    function postOp(bool hasAlreadyReverted, bytes context, uint256 actualGasCost);
}
</pre></td></tr></tbody></table></code></div></div>

<h3 id="小结-1"><span class="me-2">小结</span><a href="#小结-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>为了支持 gas 费代付，我们引入了一种新的实体类型：代付者，即部署了具有以下接口的智能合约：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Paymaster {
    function validatePaymasterOp(UserOperation op) returns (bytes context);
    function postOp(bool hasAlreadyReverted, bytes context, uint256 actualGasCost);
}
</pre></td></tr></tbody></table></code></div></div>

<p>用户操作中添加了新字段，允许钱包指定代付者：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>struct UserOperation {
    // ...
    address paymaster;
    bytes paymasterData; 
}
</pre></td></tr></tbody></table></code></div></div>

<p>代付者通过与钱包相同的方法将 ETH 存入入口点合约。入口点更新了 <code class="language-plaintext highlighter-rouge">handleOps</code> 方法，对每个操作，除了通过钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 进行钱包验证外，还会通过代付合约的 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code> 对操作进行验证。通过后执行操作，最后调用代付合约的 <code class="language-plaintext highlighter-rouge">postOp</code>。</p>

<p>为了解决模拟代付者验证时的问题，引入了质押系统，用于锁定代付者的 ETH。</p>

<p>新的入口点合约方法如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
    // ...
    function addStake() payable;
    function unlockStake();
    function withdrawStake(address payable destination);
}
</pre></td></tr></tbody></table></code></div></div>

<p>引入代付者后，我们已经实现了账户抽象的大部分功能。</p>

<h2 id="钱包创建"><span class="me-2">钱包创建</span><a href="#钱包创建" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>一个始终悬而未决的问题是用户究竟如何创建其钱包合约。传统的合约部署方式是使用 EOA 发送一个没有接收者的交易，交易中包含合约的部署代码。但我们的目标就是为了让用户在没有 EOA 的情况下也能与区块链交互，如果用户得先创建一个 EOA 才能部署钱包合约，那意义何在呢？我们希望想要但还没有钱包的用户能创建链上钱包，并支付 gas 费，可以使用 ETH 自行支付（虽然还没有钱包），也可以由代付者支付。用户应该无需创建 EOA 就能完成上述行为。</p>

<p>此外，当用户创建新 EOA 时，可以在本地生成私钥并声明账户，无需发送任何交易。我们希望合约钱包也能具有同样的属性，即在实际部署钱包合约之前，就能声明地址并接收资产。</p>

<h3 id="确定性合约地址"><span class="me-2">确定性合约地址</span><a href="#确定性合约地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>简而言之，我们需要在实际部署合约前就确定其最终的部署地址。</p>

<blockquote class="prompt-tip">
  <p>尚未部署但将被部署到的地址被称为<strong>反事实地址</strong> (counterfactual address)。</p>
</blockquote>

<p>实现这一点的关键是 <code class="language-plaintext highlighter-rouge">CREATE2</code> 操作码。它可以在不实际部署合约的情况下，根据以下输入确定合约的地址：</p>

<ul>
  <li>调用 <code class="language-plaintext highlighter-rouge">CREATE2</code> 的合约地址</li>
  <li>任意的 32 字节盐值</li>
  <li>合约的 <strong>init code</strong></li>
</ul>

<p>init code 是一段 EVM 字节码，指定了一个函数，当执行时会返回另一个 EVM 字节码，这个返回的字节码就是即将部署的智能合约代码。有趣的是：部署合约时，你提交的代码并不是最终合约中的代码，多次使用相同的 init code 并不保证部署的合约将具有相同的代码，因为 init code 可以读取存储或使用 <code class="language-plaintext highlighter-rouge">TIMESTAMP</code> 等操作码。</p>

<p>利用 <code class="language-plaintext highlighter-rouge">CREATE2</code>，我们可以让用户提供 init code，如果合约尚未存在，则由入口点部署该合约。在用户操作中添加一个新字段：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>struct UserOperation {
    // ...
    bytes initCode;
}
</pre></td></tr></tbody></table></code></div></div>

<p>并更新入口点 <code class="language-plaintext highlighter-rouge">handleOps</code> 方法中的验证部分，执行以下操作：</p>

<ul>
  <li>在验证用户操作时，如果操作有非空的 <code class="language-plaintext highlighter-rouge">initCode</code>，则使用 <code class="language-plaintext highlighter-rouge">CREATE2</code> 部署一个具有该 init code 的合约。</li>
</ul>

<p>然后像正常情况一样继续进行其余的验证：</p>
<ul>
  <li>调用新创建的钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 方法。</li>
  <li>如果操作有代付者，则调用代付合约的 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code> 方法。</li>
</ul>

<p>这一方案实现了上面讨论的目标：用户可以部署任意合约，并且可以提前知道合约将被部署的地址。部署可以由代付者赞助，或由用户自己支付（将 ETH 存入合约将被部署的地址）。</p>

<p>但该方案仍存在一些缺陷，主要围绕在让用户提交的任意字节码并由入口点对其进行验证这点：</p>

<ul>
  <li>当代付者查看用户操作时，无法通过分析字节码来决定是否为其付费。</li>
  <li>当用户提交字节码来部署合约时，难以验证所提交的字节码是否如其所愿。如果用户使用第三方工具部署合约，则要面临该工具作恶或被入侵的风险，如提交的 init code 中可能藏有后门，这类行为难以检测。</li>
  <li>由于 init code 可以是任意代码，很容易在打包器模拟时成功而在实际执行时失败。</li>
</ul>

<p>我们需要一种方式让用户能在不提交任意字节码的情况下部署合约，为其他参与者提供更多保障。</p>

<h3 id="工厂合约"><span class="me-2">工厂合约</span><a href="#工厂合约" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>我们不再让入口点直接使用任意字节码并调用 <code class="language-plaintext highlighter-rouge">CREATE2</code>，而是允许用户选择一个调用 <code class="language-plaintext highlighter-rouge">CREATE2</code> 的合约。这些合约被称为“<strong>工厂</strong>” (factory)，专门用于创建不同类型的钱包合约。</p>

<p>例如，某个工厂合约专门生成保护 NFT 的钱包，另一个工厂合约则负责生成需要$\frac{3}{5}$多签才能操作的钱包等。</p>

<p>工厂合约会暴露一个方法，用于创建合约：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>contract Factory {
   function deployContract(bytes data) returns (address);
}
</pre></td></tr></tbody></table></code></div></div>

<blockquote class="prompt-tip">
  <p>工厂返回新创建合约的地址，用户可以模拟该方法来确定其合约将被部署到何处，从而实现我们最初的目标之一。</p>
</blockquote>

<p>在用户操作中添加字段，如果用户操作要部署钱包，则指定要使用的工厂以及传递给工厂的数据：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>struct UserOperation {
  //...
  address factory; 
  bytes factoryData;
}
</pre></td></tr></tbody></table></code></div></div>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w07.drawio.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w07.drawio.svg" alt="" loading="lazy"></a>
<em>用户可以调用工厂合约，创建不同类型的合约钱包</em></p>

<p>由此，前面提到前两个问题得到了解决：</p>

<ul>
  <li>代付者可以选择仅为来自特定工厂的部署付费。</li>
  <li>如果用户调用的工厂合约经过审计，用户就一定能获得一个能达成特定目的、没有后门的合约钱包，无需审查字节码。</li>
</ul>

<p>最后一个问题是部署代码可能在模拟期间成功但在执行时失败。这与之前代付合约 <code class="language-plaintext highlighter-rouge">validatePaymasterOp</code> 方法遇到的问题一致，可以用同样的方式解决：打包器将限制工厂只能访问其关联存储及正在部署的钱包的存储，且不允许调用被禁止的方法，同时工厂需要使用入口点的 <code class="language-plaintext highlighter-rouge">addStake</code> 方法质押 ETH，打包器可根据其模拟失败的频率来限制或禁用工厂合约。</p>

<p>至此，我们的架构已经实现了 <a href="https://eips.ethereum.org/EIPS/eip-4337">ERC-4337</a> 中的全部功能。</p>

<h2 id="聚合签名"><span class="me-2">聚合签名</span><a href="#聚合签名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>当前实现下，包中的每个用户操作都需要分别进行验证，这种验证方式会带来不必要的 gas 消耗，导致验签成本高昂。</p>

<p>因此，我们可以引入密码学中的聚合签名，用一个签名同时验证多个操作，以节省 gas。</p>

<p>聚合签名方案中，给定多个由不同密钥签名的消息，生成一个单一的聚合签名，该聚合签名通过验证就意味着所有签名都是有效的。</p>

<p><a href="https://en.wikipedia.org/wiki/BLS_digital_signature">BLS</a> 就是一个支持聚合的常见签名方案。</p>

<p>这种优化对于实现 Rollup 尤其有用，因为 Rollup 的主要目标就是数据压缩，而签名聚合令签名部分可被压缩。</p>

<p>关于签名聚合带来的空间节省可参见 Vitalik 的推文：</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Some quick theorycrafting of how much data space we can save by improving compression (especially in rollups).<br /><br />ERC4337 signature aggregation ( <a href="https://t.co/wFJI3BEq6g">https://t.co/wFJI3BEq6g</a> ) is essential to this. <a href="https://t.co/nrlcOpVJKb">pic.twitter.com/nrlcOpVJKb</a></p>&mdash; vitalik.eth (@VitalikButerin) <a href="https://twitter.com/VitalikButerin/status/1554983955182809088?ref_src=twsrc%5Etfw">August 4, 2022</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h3 id="聚合器"><span class="me-2">聚合器</span><a href="#聚合器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>包中并非所有用户操作的签名都可以聚合。由于钱包可以使用任意逻辑来验证给定的签名，因此一个包中可能存在各种签名方案。</p>

<p>不同方案的签名无法聚合，因此最终包中会得到几组操作，每组使用不同的聚合方案，甚至也可能不进行聚合。我们使用多个名为<strong>聚合器</strong> (aggregator) 的合约来在链上表示不同的聚合方案。</p>

<p>一个聚合方案包括聚合（定义如何将多个签名聚合成一个）和验证（定义如何验证聚合签名）两部分，因此聚合器合约暴露以下两个方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Aggregator {
    function aggregateSignatures(UserOperation[] ops) returns (bytes aggregatedSignature);
    function validateSignatures(UserOperation[] ops, bytes signature);
}
</pre></td></tr></tbody></table></code></div></div>

<p>由于钱包能定义其签名方案，因此由钱包来决定与哪个聚合器兼容。如果钱包想要参与聚合，会公开一个方法来选择聚合器：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Wallet {
    // ...
    function getAggregator() returns (address);
}
</pre></td></tr></tbody></table></code></div></div>

<p>使用这个新的 <code class="language-plaintext highlighter-rouge">getAggregator</code> 方法，打包器可以将使用相同聚合器的操作分组，并使用该聚合器的 <code class="language-plaintext highlighter-rouge">aggregateSignatures</code> 方法为其计算聚合签名。</p>

<p>操作组如下所示：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>struct UserOpsPerAggregator {
    UserOperation[] ops;
    address aggregator;
    bytes combinedSignature;
}
</pre></td></tr></tbody></table></code></div></div>

<blockquote class="prompt-tip">
  <p>如果打包器有特定聚合器链下知识，则可通过硬编码签名聚合算法的本地版本来进行优化，无需运行 <code class="language-plaintext highlighter-rouge">aggregateSignatures</code> 的 EVM 代码。</p>
</blockquote>

<p>更新入口点合约，提供新方法 <code class="language-plaintext highlighter-rouge">handleAggregatedOps</code>，该方法与 <code class="language-plaintext highlighter-rouge">handleOps</code> 作用基本相同，但接收按聚合器分组的操作，主要区别在于验证步骤。</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>contract EntryPoint {
    function handleOps(UserOperation[] ops);
    function handleAggregatedOps(UserOpsPerAggregator[] ops);
    // ...
}
</pre></td></tr></tbody></table></code></div></div>

<p><code class="language-plaintext highlighter-rouge">handleOps</code>通过调用每个钱包的 <code class="language-plaintext highlighter-rouge">validateOp</code> 方法来执行验证，而 <code class="language-plaintext highlighter-rouge">handleAggregatedOps</code> 则使用每组的聚合器在对聚合签名调用 <code class="language-plaintext highlighter-rouge">validateSignatures</code> 方法。</p>

<p><a href="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w08.drawio.svg" class="popup img-link  shimmer"><img src="https://fanwb.oss-cn-beijing.aliyuncs.com/img/w08.drawio.svg" alt="" loading="lazy"></a>
<em>执行者用聚合器将用户操作分组，并发送至入口点，以同时进行验证</em></p>

<p>最后，同样需要对聚合器进行限制以避免打包器模拟失真的问题：限制聚合器可访问的存储即可使用的操作码，并要求其在入口点合约中质押 ETH。</p>

<p><strong>至此，我们实现了 ERC-4337 的完整架构</strong>，仅在方法名和参数等细节方面存在差异。</p>

<h2 id="总结"><span class="me-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>本文从用户需求和实际使用场景出发，逐步介绍了账户抽象的架构设计思路和演进过程，最终实现了 ERC-4337 的全部核心功能。希望本文的解析能够帮助读者更好地理解账户抽象这一复杂概念的来龙去脉，并从中获得有价值的启发。</p>

<h2 id="附录与-erc-4337-的差异"><span class="me-2">附录：与 ERC-4337 的差异</span><a href="#附录与-erc-4337-的差异" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p><strong>1. 验证时间范围</strong></p>

<p>钱包希望用户操作仅在一定时间段内有效，否则恶意打包器可以长时间囤积操作，仅在对打包器有利的时间点将其包含在包中。</p>

<p>钱包无法通过检查 <code class="language-plaintext highlighter-rouge">TIMESTAMP</code> 来避免这种情况，因为我们为防止模拟失真在验证期间禁用了 <code class="language-plaintext highlighter-rouge">TIMESTAMP</code>。因此我们需要另外的方式来指示操作有效的时间段。</p>

<p>ERC-4337 给了 <code class="language-plaintext highlighter-rouge">validateOp</code> 返回值，钱包可以利用该值选择时间段：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Wallet {
   function validateOp(UserOperation op, uint256 requiredPayment) returns (uint256 sigTimeRange);
   // ...
}
</pre></td></tr></tbody></table></code></div></div>

<p>此返回值表示操作有效的时间段，由两个连续的 8 字节整数表示。</p>

<p>ERC-4337 中还有一点说明：在验证失败的情况下，钱包应该从 <code class="language-plaintext highlighter-rouge">validateOp</code> 返回一个哨兵值，而不是回滚，这有助于估算 gas，因为 <code class="language-plaintext highlighter-rouge">eth_estimateGas</code> 无法告诉你回滚的交易使用了多少 gas。</p>

<p><strong>2. 任意调用数据</strong></p>

<p>我们的钱包接口是：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>contract Wallet {
   function validateOp(UserOperation op, uint256 requiredPayment); 
   function executeOp(UserOperation op);
}
</pre></td></tr></tbody></table></code></div></div>

<p>在 ERC-4337 中，钱包没有名为 <code class="language-plaintext highlighter-rouge">executeOp</code> 的方法。与之相对，用户操作中有一个 <code class="language-plaintext highlighter-rouge">callData</code> 字段，这被作为调用数据传递给钱包：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>struct UserOperation {
   // ...
   bytes callData;
}
</pre></td></tr></tbody></table></code></div></div>

<p>对于一般的智能合约，此数据的前 4 个字节被解释为函数标识符，其余部分为函数参数。</p>

<p>这意味着除了必需的 <code class="language-plaintext highlighter-rouge">validateOp</code> 方法之外，钱包可以自定义接口，用户操作可用于调用钱包中的任意方法。</p>

<p>同样，在 ERC-4337 中，工厂合约也没有 <code class="language-plaintext highlighter-rouge">deployContract</code> 方法，而是接收来自操作的 <code class="language-plaintext highlighter-rouge">initCode</code> 字段的任意调用数据。</p>

<p><strong>3.压缩数据</strong></p>

<p>用户操作包含指定代付者的字段以及要传递的数据：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>struct UserOperation {
   // ...
   address paymaster;
   bytes paymasterData;
}
</pre></td></tr></tbody></table></code></div></div>

<p>在 ERC-4337 中，二者被优化为一个字段，该字段的前 20 字节是代付者地址，其余部分是数据：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>struct UserOperation {
   // ...
   bytes paymasterAndData;
}  
</pre></td></tr></tbody></table></code></div></div>

<p>工厂合约也是如此：ERC-4337 将 <code class="language-plaintext highlighter-rouge">factory</code> 和 <code class="language-plaintext highlighter-rouge">factoryData</code> 两个字段合并为了 <code class="language-plaintext highlighter-rouge">initCode</code>。</p>

<hr />

<p><strong>参考：</strong></p>

<p>[1] <a href="https://eips.ethereum.org/EIPS/eip-4337">ERC-4337: Account Abstraction Using Alt Mempool</a></p>

<p>[2] <a href="https://www.alchemy.com/blog/account-abstraction">You Could Have Invented Account Abstraction</a></p>

<p>[3] <a href="https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a">ERC 4337: account abstraction without Ethereum protocol changes</a></p>

  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    
      <div class="post-meta mb-3">
        <i class="far fa-folder-open fa-fw me-1"></i>
        
          <a href="/categories/blockchain/">Blockchain</a>,
          <a href="/categories/ethereum/">Ethereum</a>
      </div>
    

    <!-- tags -->
    
      <div class="post-tags">
        <i class="fa fa-tags fa-fw me-1"></i>
        
          <a
            href="/tags/account-abstraction/"
            class="post-tag no-text-decoration"
          >account abstraction</a>
        
      </div>
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          This post is licensed under 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         by the author.
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">Share</span>
  <span class="share-icons">
    
    
    

    

      

      <a href="https://twitter.com/intent/tweet?text=%E8%B4%A6%E6%88%B7%E6%8A%BD%E8%B1%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3%20-%20Fanwb's%20Blog&url=https%3A%2F%2Ffan-wb.github.io%2Fposts%2Faa%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter">
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    

      

      <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%B4%A6%E6%88%B7%E6%8A%BD%E8%B1%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3%20-%20Fanwb's%20Blog&u=https%3A%2F%2Ffan-wb.github.io%2Fposts%2Faa%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook">
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    

      

      <a href="https://t.me/share/url?url=https%3A%2F%2Ffan-wb.github.io%2Fposts%2Faa%2F&text=%E8%B4%A6%E6%88%B7%E6%8A%BD%E8%B1%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3%20-%20Fanwb's%20Blog" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram">
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted">
            <div class="access">
              <!-- Get 5 last posted/updated posts -->














  <section id="access-lastmod">
    <h2 class="panel-heading">Recently Updated</h2>
    <ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/lmdghost/">以太坊 PoS 共识协议详解（一）：核心概念与 LMD GHOST</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/casperffg/">以太坊 PoS 共识协议详解（二）：Casper FFG</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/rwa/">RWA 代币化浪潮：万物皆可加密</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/aicrypto/">AI × 加密：去中心化愿景的现实考验</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/privacyprotection/">隐私保护工具推荐</a>
        </li>
      
    </ul>
  </section>
  <!-- #access-lastmod -->


              <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">Trending Tags</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ethereum/">ethereum</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/consensus/">consensus</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/privacy/">privacy</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/rollup/">rollup</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/blockchain/">blockchain</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/defi/">defi</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ipfs/">ipfs</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pos/">pos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/account-abstraction/">account abstraction</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ai/">ai</a>
      
    </div>
  </section>


            </div>

            
              
              



  <section id="toc-wrapper" class="ps-0 pe-4">
    <h2 class="panel-heading ps-3 pt-2 mb-2">Contents</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->














  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  











  <aside id="related-posts" aria-labelledby="related-label">
    <h3 class="mb-4" id="related-label">Further Reading</h3>
    <nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        <article class="col">
          <a href="/posts/lmdghost/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1681531200"
  data-df="ll"
  
>
  Apr 15, 2023
</time>

              <h4 class="pt-0 my-2">以太坊 PoS 共识协议详解（一）：核心概念与 LMD GHOST</h4>
              <div class="text-muted">
                <p>
                  





                  本文是介绍以太坊 PoS 共识协议的第一部分。主要包括对术语和核心概念的讲解，以及对 LMD GHOST 分叉选择规则的详细介绍。

术语及重要概念

节点和验证者

以太坊网络的主要参与者是节点 (Node)。节点的作用是验证共识并与其他节点形成通信骨干网。共识由验证者 (Validator) 形成。


  “验证者”这一术语具有一定的误导性，验证者其实并不会验证任何东西，验证是由节点完...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/casperffg/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1690084800"
  data-df="ll"
  
>
  Jul 23, 2023
</time>

              <h4 class="pt-0 my-2">以太坊 PoS 共识协议详解（二）：Casper FFG</h4>
              <div class="text-muted">
                <p>
                  





                  本文是介绍以太坊 PoS 共识协议的第二部分，主要对最终性工具 Casper FFG 进行全面说明。

许多文章都介绍过 Casper FFG 的运行机制，但很少解释这些机制为什么有效。希望本文能为读者理解 Casper FFG 的有效性提供一些参考。

总体而言，Casper FFG 的机制并不复杂，其有效性主要归功于为两个重要理念：两阶段提交，以及可问责安全性。

两阶段提交赋予了 Ca...
                </p>
              </div>
            </div>
          </a>
        </article>
      
        <article class="col">
          <a href="/posts/ethds/" class="post-preview card h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1695096000"
  data-df="ll"
  
>
  Sep 19, 2023
</time>

              <h4 class="pt-0 my-2">以太坊数据结构详解</h4>
              <div class="text-muted">
                <p>
                  





                  以太坊的实现中涉及了多种数据结构和编码规则，全面深入地理解这些内容对研究者和开发者来说至关重要。目前，该领域的主要信息来源是以太坊黄皮书、以太坊开发者文档以及网络上大量的非正式博客文章。黄皮书内容全面，但难称详略得当，易读性较低，且省略了智能合约数据的结构和存储信息。以太坊开发者文档的内容组织散乱，依赖众多外部博客和视频链接的补充完善。以太坊创始人 Antonopoulos 和 Wood 出...
                </p>
              </div>
            </div>
          </a>
        </article>
      
    </nav>
  </aside>
  <!-- #related-posts -->


            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/floo/"
      class="btn btn-outline-primary"
      aria-label="Older"
    >
      <p>文件同步系统 Floo 基本功能演示</p>
    </a>
  

  
    <a
      href="/posts/lmdghost/"
      class="btn btn-outline-primary"
      aria-label="Newer"
    >
      <p>以太坊 PoS 共识协议详解（一）：核心概念与 LMD GHOST</p>
    </a>
  
</nav>

            
              
              <!--  The comments switcher -->

  
  <!-- https://giscus.app/ -->
<script type="text/javascript">
  (function () {
    const origin = 'https://giscus.app';
    const iframe = 'iframe.giscus-frame';
    const lightTheme = 'light';
    const darkTheme = 'dark_dimmed';

    let initTheme = lightTheme;
    const html = document.documentElement;

    if (
      (html.hasAttribute('data-mode') &&
        html.getAttribute('data-mode') === 'dark') ||
      (!html.hasAttribute('data-mode') &&
        window.matchMedia('(prefers-color-scheme: dark)').matches)
    ) {
      initTheme = darkTheme;
    }

    let giscusAttributes = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'fan-wb/fan-wb.github.io',
      'data-repo-id': 'R_kgDOIpbGbQ',
      'data-category': 'Announcements',
      'data-category-id': 'DIC_kwDOIpbGbc4CimRo',
      'data-mapping': 'pathname',
      'data-reactions-enabled': '1',
      'data-emit-metadata': '0',
      'data-theme': initTheme,
      'data-input-position': 'top',
      'data-lang': 'zh-CN',
      'data-loading': 'lazy',
      crossorigin: 'anonymous',
      async: ''
    };

    let giscusScript = document.createElement('script');
    Object.entries(giscusAttributes).forEach(([key, value]) =>
      giscusScript.setAttribute(key, value)
    );
    document.getElementById('tail-wrapper').appendChild(giscusScript);

    addEventListener('message', (event) => {
      if (
        event.source === window &&
        event.data &&
        event.data.direction === ModeToggle.ID
      ) {
        /* global theme mode changed */
        const mode = event.data.message;
        const theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme;

        const message = {
          setConfig: {
            theme: theme
          }
        };

        const giscus = document.querySelector(iframe).contentWindow;
        giscus.postMessage({ giscus: message }, origin);
      }
    });
  })();
</script>



            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>©
    <time>2024</time>

    
      <a href="https://github.com/fan-wb">Fan-WB</a>.
    

    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title=""
      ><a href='https://beian.miit.gov.cn/' target='_blank'>京ICP备2024091746号-1</a></span>
    
  </p>

  <p>Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">Trending Tags</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ethereum/">ethereum</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/consensus/">consensus</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/privacy/">privacy</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/rollup/">rollup</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/blockchain/">blockchain</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/defi/">defi</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ipfs/">ipfs</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pos/">pos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/account-abstraction/">account abstraction</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/ai/">ai</a>
      
    </div>
  </section>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">A new version of content is available.</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      Update
    </button>
  </div>
</aside>

    

    <!-- JavaScripts -->

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->




  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/en.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.25.0/dist/tocbot.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>


  <!-- MathJax -->
  <script>
    /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */
    MathJax = {
      tex: {
        /* start/end delimiter pairs for in-line math */
        inlineMath: [
          ['$', '$'],
          ['\\(', '\\)']
        ],
        /* start/end delimiter pairs for display math */
        displayMath: [
          ['$$', '$$'],
          ['\\[', '\\]']
        ],
        /* equation numbering */
        tags: 'ams'
      }
    };
  </script>
  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script>





    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{snippet}</p>  </article>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

